es7:数组 includes()方法，用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回 false。
`a ** b`指数运算符，它与 Math.pow(a, b)相同。
es8:`async与await`

#### let

块级变量声明，所声明的变量只在 `let` 命令所在的代码块内有效

1. 不存在变量提升(变量提升：变量可以在声明之前使用)

2. 暂时性死区

   区块中只要存在`let`和`const`命令，这个区块对这些命令声明的变量，就形成了封闭作用域。凡在声明之前使用这些变量，就会报错。

3. 不允许重复声明

#### const

1. const 关键字声明变量时，必须有个初始值，否则会报错。
2. const 声明的变量不可以通过再赋值修改,会报错。

```javascript
const a = 5;
a = 9; //Uncaught TypeError: Assignment to constant variable.
```

3. const 定义的常量并非真正的常量。定义的数组或对象是可以改变的，可以改变（包括修改和添加）数组里的元素和对象里的属性。但是对数组和对象再赋值依然是不可以的
   > const 实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。
   > 对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const 只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。

```javascript
const arr = [1, 2, 4];
arr[2] = 8;
console.log(arr); //[1,2,8]

//不可以再赋值
arr = [2, 3]; ////Uncaught TypeError: Assignment to constant variable.
```

4. 具有`let`一样的属性。
